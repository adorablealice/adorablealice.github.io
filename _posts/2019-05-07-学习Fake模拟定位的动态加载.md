---
layout:     post                    # 使用的布局（不需要改）
title:      分析Fake Location的SO注入      # 标题 
subtitle:   安卓逆向 SO注入 #副标题
date:       2019-05-07              # 时间
author:     BC                      # 作者
header-img: img/post-bg-fake.png    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 安卓逆向
---

## 前言
    笔者最近玩一个山寨pokemongo的手游 使用了Fake Location作为模拟定位软件，对其中反检测功能的实现原理颇为感兴趣
    想知道他是怎么绕过ptrace保护注入进程 实现hook功能的
    这项技术的意义在于可以加固保护有hook功能的程序 而xposed插件就是近乎裸奔
    

## 分析SuperSU日志
![SuperSU日志](img/post-fake-supersu.png)
  
inject -P zygote -l initzygote.so -n fakelocation  
可以看出是zygote注入，zygote注入可以解决目标进程被ptrace保护的问题  
linux的zygote机制此处略  
向zygote进程中注入initzygote.so文件，fakelocation包名作为白名单不注入。


## 分析initzygote.so

```c
int init(void)
{
  int v0; // r0
  JNIEnv *v1; // r4
  int v2; // r0
  bool v3; // zf
  int v4; // ST24_4
  int v5; // ST10_4
  int v6; // r5
  int v7; // r9
  int v8; // ST18_4
  int v9; // r8
  int v10; // r0
  int v11; // ST1C_4
  int v12; // r6
  int v13; // r6
  int v14; // ST14_4
  int v15; // r8
  int v16; // r5
  int v17; // ST0C_4
  int result; // r0
  signed int v19; // r0
  const char *v20; // r2
  char s; // [sp+28h] [bp-220h]
  int v22; // [sp+228h] [bp-20h]

  v0 = _android_log_print(4, "LINJECT.native", "InitApp is Executing!!");
  v1 = (JNIEnv *)j_getJniEnv(v0);
  if ( !v1 )
  {
    result = _stack_chk_guard - v22;
    if ( _stack_chk_guard != v22 )
      return result;
    v19 = 4;
    v20 = "jni_env is NULL!!";
    goto LABEL_11;
  }
  v2 = j_isSignQualified();
  v3 = v2 == -2;
  if ( v2 != -2 )
    v3 = v2 == 0;
  if ( v3 )
  {
    __android_log_print(4, "LINJECT.native", "jni_env is %p", v1);
    v4 = ((int (__fastcall *)(JNIEnv *, const char *))(*v1)->NewStringUTF)(v1, "/data/fakeloc/zygote_dex");
    v5 = ((int (__fastcall *)(JNIEnv *, char *))(*v1)->NewStringUTF)(v1, apkpath[0]);
    v6 = ((int (__fastcall *)(JNIEnv *, const char *))(*v1)->FindClass)(v1, "dalvik/system/DexClassLoader");
    snprintf(
      &s,
      0x200u,
      "(%s%s%s%s)V",
      "Ljava/lang/String;",
      "Ljava/lang/String;",
      "Ljava/lang/String;",
      "Ljava/lang/ClassLoader;");
    v7 = ((int (__fastcall *)(JNIEnv *, int, const char *, char *))(*v1)->GetMethodID)(v1, v6, "<init>", &s);
    snprintf(&s, 0x200u, "(%s)%s", "Ljava/lang/String;", "Ljava/lang/Class;");
    v8 = v6;
    v9 = ((int (__fastcall *)(JNIEnv *, int, const char *, char *))(*v1)->GetMethodID)(v1, v6, "loadClass", &s);
    v10 = j_getSystemClassLoader(v1);
    v11 = v10;
    v12 = v10;
    __android_log_print(4, "LINJECT.native", "Oat2dex...");
    v13 = _JNIEnv::NewObject(v1, v6, v7, v5, v4, 0, v12);
    __android_log_print(4, "LINJECT.native", "Oat2dex OK.");
    v14 = ((int (__fastcall *)(JNIEnv *, const char *))(*v1)->NewStringUTF)(
            v1,
            "com.lerist.inject.fakelocation.InjectDex");
    v15 = _JNIEnv::CallObjectMethod(v1, v13, v9, v14);
    __android_log_print(4, "LINJECT.native", "entry_class:%p", v15);
    v16 = ((int (__fastcall *)(JNIEnv *, int, const char *, const char *))(*v1)->GetStaticMethodID)(
            v1,
            v15,
            "initZygote",
            "(Ljava/lang/Object;)[Ljava/lang/Object;");
    __android_log_print(4, "LINJECT.native", "Invoke method...");
    v17 = _JNIEnv::CallStaticObjectMethod(v1, v15, v16, 0);
    __android_log_print(4, "LINJECT.native", "InitApp is finished");
    ((void (__fastcall *)(JNIEnv *, int))(*v1)->DeleteLocalRef)(v1, v4);
    ((void (__fastcall *)(JNIEnv *, int))(*v1)->DeleteLocalRef)(v1, v5);
    ((void (__fastcall *)(JNIEnv *, int))(*v1)->DeleteLocalRef)(v1, v4);
    ((void (__fastcall *)(JNIEnv *, int))(*v1)->DeleteLocalRef)(v1, v8);
    ((void (__fastcall *)(JNIEnv *, int))(*v1)->DeleteLocalRef)(v1, v11);
    ((void (__fastcall *)(JNIEnv *, int))(*v1)->DeleteLocalRef)(v1, v13);
    ((void (__fastcall *)(JNIEnv *, int))(*v1)->DeleteLocalRef)(v1, v14);
    ((void (__fastcall *)(JNIEnv *, int))(*v1)->DeleteLocalRef)(v1, v15);
    ((void (__fastcall *)(JNIEnv *, int))(*v1)->DeleteLocalRef)(v1, v17);
    return _stack_chk_guard - v22;
  }
  result = _stack_chk_guard - v22;
  if ( _stack_chk_guard == v22 )
  {
    v19 = 6;
    v20 = "Illegal application!";
LABEL_11:
    result = j___android_log_print(v19, "LINJECT.native", v20);
  }
  return result;
}
```
main函数里 反射执行了com.lerist.inject.fakelocation.InjectDex.initZygote方法
```java
public static java.lang.Object[] initZygote(java.lang.Object r3) {
        r0 = new java.lang.StringBuilder;
        r0.<init>();
        r1 = "initZygote.";
        r0.append(r1);
        r0.append(r3);
        r3 = r0.toString();
        r0 = "InjectDex";
        android.util.Log.d(r0, r3);
        r3 = new java.lang.StringBuilder;
        r3.<init>();
        r1 = "";
        r3.append(r1);
        r1 = android.os.Build.CPU_ABI;
        r3.append(r1);
        r3 = r3.toString();
        r1 = "64";
        r3 = r3.contains(r1);
        if (r3 == 0) goto L_0x0034;
    L_0x0031:
        r3 = "/data/fakeloc/liblhooker64.so";
        goto L_0x0036;
    L_0x0034:
        r3 = "/data/fakeloc/liblhooker.so";
    L_0x0036:
        com.lerist.lib.lhooker.LHooker.a(r3);
        r3 = 0;
        a.a.c.a.a.hook(r3);
        r1 = new java.lang.StringBuilder;
        r1.<init>();
        r2 = "initZygote finish.";
        r1.append(r2);
        r2 = com.lerist.lib.lhooker.LHooker.a;
        r1.append(r2);
        r1 = r1.toString();
        android.util.Log.d(r0, r1);
        return r3;
    }

```
在这里System.load加载了liblhooker.so 为hook库  
com.lerist.lib.lhooker.LHooker类中有多个hook相关JNI方法
```java
    public static native java.lang.Object findMethodNative(java.lang.Class r1, java.lang.String r2, java.lang.String r3);

    public static native java.lang.Object[] getKeys(byte[] r1, java.lang.String r2);

    private static native boolean hookMethodNative(java.lang.Object r1, java.lang.reflect.Method r2, java.lang.reflect.Method r3, java.lang.reflect.Method r4);

    public static native int init(int r1);

    public static native void resumeAll(long r1);

    public static native long suspendAll();

```

## 第一步小结
    1. Fake软件使用了非xposed的hook库
    2. 通过zygote注入loader So 反射加载dex，在该dex里加载Hook用so
    3. 这样做的好处是可以绕过常见xposed检测，又可以对APP进行加固
    4.笔者下一步选择使用whale或其他框架+inlinehook，实现自己的hook工具
    

## 动手模仿
### hook框架选择
      笔者找到好几种hook方案，从较早期的StormHook到最新的Whale，包括中间的FastHook
    在StormHook中有详细的注入教程https://bbs.pediy.com/thread-220760.htm
    而且Fake使用的看上去像是Epic 本着用新不用旧的原则，踏进了新坑
    于是我本准备使用Whale框架 遇到了以下问题 最终还是使用了Epic框架
    
### 问题1 Whale框架不可用
    在注入的dex中System.load加载libwhale.so以后，JNI_Onload就加载失败 报错信息
    JNI_ERR returned from JNI_OnLoad in "/data/shithack/libwhale.so"
    机型 小米6 安卓7.1
    尝试在源码里插log调试（或者直接用更稳定的Epic）
    经测试Epic稳定可用
    
### 问题2 dlopen和dlsym 获取不到libart.so
    这个是7.0以上so文件安全性 关于namespace的问题
    使用了Nougat_dlfunctions 的fake_dlfcn也没有用
    只能从initzygote.so里抠代码出来 居然可以 奇怪
    分析代码 关键点
```c
   while ( !handle && i <= 1 )
    {
        dlerror();
        handle = dlopen(0, 1);
        error = dlerror();
        if ( error )
            LOGD( "BCINJECT.native failed to load %s: %s", paths[i], error);
        if ( handle )
            LOGD( "BCINJECT.native Android runtime loaded from %s", paths[i]);
        else
            ++i;
    }
```
    乍一看非常奇怪 怎么第一个参数可以是NULL呢 随便google一下没有找到答案
    于是开始dlopen分析源码
[参考dlopen分析文章](https://blog.csdn.net/SweeNeil/article/details/83744843)  
[参考函数文档](https://www.xuebuyuan.com/1912632.html)
    
If file is a null pointer, dlopen() shall return a global symbol table handle for the currently running process image. This symbol table handle shall provide access to the symbols from an ordered set of executable object files consisting of the original program image file, any executable object files loaded at program start-up as specified by that process file (for example, shared libraries), and the set of executable object files loaded using dlopen() operations with the RTLD_GLOBAL flag. As the latter set of executable object files can change during execution, the set of symbols made available by this symbol table handle can also change dynamically.  
    
    第一个参数fileName为空时，handle指向当前进程镜像的全局符号表。
    handle类似迭代器指针，每调用一次指向下一个模块。
    在Android中，符号表首部的应该就是jvm相关 libart或libdvm。
    所以我们可以获取到JavaVM* 获取到JNIEnv*
    

### 问题3 插件目录归属用户问题
    插件加载的目录归属用户 需要与目标进程的用户相同
    如果是zygote注入 都是root 问题不大 其他进程需要经常chown插件目录
    
### Epic代码编写
    Epic就是Dexposed在ART上的续命，兼容了Dexposed的语法，对于Xposed移植非常友好
    示例如下
```java
public class HookMain {

    public static void hookAll() {
        DexposedBridge.findAndHookMethod(Log.class,
                "e", String.class, String.class, new XC_MethodHook() {
                    @Override
                    protected void beforeHookedMethod(XC_MethodHook.MethodHookParam param) throws Throwable {
                        //Log.e("SHITHOOK", "Log " + String.valueOf(param.args[0])+" "+String.valueOf(param.args[1]));
                        param.args[1] = "test hooked success";
                    }
                });

        DexposedBridge.findAndHookMethod(Activity.class,
                "onCreate", Bundle.class, new XC_MethodHook() {
                    @Override
                    protected void afterHookedMethod(XC_MethodHook.MethodHookParam param) throws Throwable {
                        Log.e("SHITHOOK", "onCreate " + String.valueOf(param.thisObject));
                    }
                });
    }
}
```

    
    
    
    
    
    
    

    

> to be continued
